!    -*- f90 -*-
! Note: the context of this file is case sensitive.
! Shorthand Notations:
! --------------------
! <prefix=s,d,c,z>
! <prefix2=s,d>
! <prefix2c=c,z>
! <ftype=real,double precision,complex,double complex>
! <ftype2=real,double precision>
! <ftype2c=complex,double complex>
! <ftypereal=real,double precision,real,double precision>
! <ftypecomplex=complex,double complex,\0,\1>
! <ctype=float,double,complex_float,complex_double>
! <ctype2=float,double>
! <ctype2c=complex_float,complex_double>
! <ctypereal=float,double,float,double>
! <ctypecomplex=complex_float,complex_double,\0,\1>
! <wrap2=ws,d>
! <wrap2c=wc,z>
!

subroutine <prefix>gebal(scale,permute,n,a,m,lo,hi,pivscale,info)
    !
    ! ba,lo,hi,pivscale,info = gebal(a,scale=0,permute=0,overwrite_a=0)
    ! Balance general matrix a.
    ! hi,lo are such that ba[i][j]==0 if i>j and j=0...lo-1 or i=hi+1..n-1
    ! pivscale([0:lo], [lo:hi+1], [hi:n+1]) = (p1,d,p2) where (p1,p2)[j] is
    ! the index of the row and column interchanged with row and column j.
    ! d[j] is the scaling factor applied to row and column j.
    ! The order in which the interchanges are made is n-1 to hi+1, then 0 to lo-1.
    !
    ! P * A * P = [[T1,X,Y],[0,B,Z],[0,0,T2]]
    ! BA = [[T1,X*D,Y],[0,inv(D)*B*D,ind(D)*Z],[0,0,T2]]
    ! where D = diag(d), T1,T2 are upper triangular matrices.
    ! lo,hi mark the starting and ending columns of submatrix B.

    callstatement { (*f2py_func)((permute?(scale?"B":"P"):(scale?"S":"N")),&n,a,&m,&lo,&hi,pivscale,&info); hi--; lo--; }
    callprotoargument char*,F_INT*,<ctype>*,F_INT*,F_INT*,F_INT*,<ctypereal>*,F_INT*
    integer intent(in),optional :: permute = 0
    integer intent(in),optional :: scale = 0
    integer intent(hide),depend(a,n) :: m = shape(a,0)
    integer intent(hide),depend(a) :: n = shape(a,1)
    check(m>=n) m
    integer intent(out) :: hi,lo
    <ftypereal> dimension(n),intent(out),depend(n) :: pivscale
    <ftype> dimension(m,n),intent(in,out,copy,out=ba) :: a
    integer intent(out) :: info

end subroutine <prefix>gebal

subroutine <prefix>ggbal(scale,permute,n,a,lda,b,ldb,lo,hi,lscale,rscale,work,lwork,info) ! in zggbal.f
  !          WORK is DOUBLE PRECISION array, dimension (lwork)
  !          lwork must be at least max(1,6*N) when JOB = 'S' or 'B', and
  !          at least 1 when JOB = 'N' or 'P'.
    callstatement { (*f2py_func)((permute?(scale?"B":"P"):(scale?"S":"N")),&n,a,&lda,b,&ldb,&lo,&hi,lscale,rscale,work,&info); hi--; lo--; }
    callprotoargument char*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,F_INT*,F_INT*,<ctypereal>*,<ctypereal>*,<ctype>*,F_INT*
    integer intent(in),optional :: permute = 0
    integer intent(in),optional :: scale = 0
    integer intent(hide),depend(a) :: n = shape(a,1)
    integer intent(hide),depend(a,n) :: lda = shape(a,0)
    integer intent(hide),depend(b,n) :: ldb = shape(b,0)
    check(lda>=n) lda
    check(ldb>=n) ldb
    <ftype> dimension(lda,n),intent(in,out,copy,out=ao) :: a
    <ftype> dimension(ldb,n),intent(in,out,copy,out=bo) :: b
    integer intent(out) :: hi,lo
    <ftypereal> dimension(n),intent(out),depend(n) :: lscale
    <ftypereal> dimension(n),intent(out),depend(n) :: rscale
    <ftype> precision intent(hide,cache),dimension(lwork),depend(lwork) :: work
    integer optional :: lwork = (scale?max(1,6*n):1)
    integer intent(out) :: info
end subroutine <prefix>gebal

